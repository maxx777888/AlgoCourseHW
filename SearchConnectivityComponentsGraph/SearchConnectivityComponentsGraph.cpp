//Поиск компонентов связности
#include <iostream>
#include <fstream>

//Функция создает двумерные массивы. 
int** create2arr(const int ROWS, const int COLUMNS)
{
    int** arr2d = new int* [ROWS];
    for (int i = 0; i < ROWS; i++)
    {
        arr2d[i] = new int[COLUMNS];
    }
    return arr2d;
}

//Функция очищает динамическую память, удаляя двумерный массив. 
void delete2dArr(int** arr2d, const int ROWS)//Функция стерает двумерный массив
{
    for (int i = 0; i < ROWS; i++)
    {
        delete[] arr2d[i];
    }
    delete[] arr2d;
    arr2d = nullptr;
}

int main()
{
    setlocale(LC_ALL, "Russian");
    std::ifstream f_in("input.txt");

    if (f_in.is_open()) //Проверка на наличие файла in.txt
    {
        //Создаем двумерный пустой массив 
        int arr_size;//Переменная будет хранить размер массива
        f_in >> arr_size;
        int** fArr = create2arr(arr_size, arr_size);//Двумерный массив

        //Считывание и запись массива графа
        for (int i = 0; i < arr_size; i++)
        {
            for (int j = 0; j < arr_size; j++)
            {
                f_in >> fArr[i][j];
            }
        }
        

        //Начало поиска компонентов
        int connect = 0;// Переменная для сохранения кол-ва компанентов сложности. 
        int* vArr = new int[arr_size]();//Массив куда будут складыватся уже включенные компоненты
        bool stopSearch = false;//Флаг для окончания процесса поиска
        int vertex = 0;//Начало поиска с первой вершины
        std::cout << "Принадлежность вершин компонентам связности: " << std::endl;
        do 
        {//Цикл поиска компонентов связности

            //Создаем массив для сохранения вершин отдельного компонента связности, максимальный размер - все вершины.
            int* visArr = new int[arr_size];
            for (int i = 0; i < arr_size; i++)//На все позиции в массиве ставим ноль
            {
                visArr[i] = 0;
            }
            visArr[vertex] = 1;//Сразу присваиваем ячейке, с которой начнется поиск 1

            if (vArr[vertex] != 1) {
                vArr[vertex] = 1;//Так же добавляем 1 в массив всех проверенных вершин
            }
            
            int hasVertex = 0;//Переменная для прохода по динамическому массиву 
            
            while (vertex < arr_size) {

                bool f = true;//Переменная отслеживает самую первую вершину, которая еще не проверялась
                bool f1 = true;//Переменная отслеживает самую первую вершину, которая уже проверялась
                for (int i = 0; i < arr_size; i++)//Начинаем проход по массиву
                {
                    
                    if (fArr[vertex][i] == 1) //Проверка на смежность
                    {
                        if (visArr[i] != 1) //Если еще нет данных о вершине в массиве вершин на проверке
                        { 
                            visArr[i] = 1;//Отмечаем вершину в массиве на проверку
                            if (f == true)//Проверка если это первая вершина в проходе
                            {
                                hasVertex = i;//Отмечаем, что следующий проход по массиву начнется с этой вершины
                                f = false;//Меняем флаг 
                                f1 = false;//Меняем флаг
                            }
                            

                            if (vArr[i] != 1) //Заносим вершину в основной массив посещенных вершин
                            {
                                vArr[i] = 1;
                            }
                        }
                        else { //Если вершина уже была посещена, но ее еще не проверяли на смежность с другими вершинами
                            if (f1 == true && f == true && vertex != hasVertex) {
                                hasVertex = i;//Переходим на эту вершину в следующем проходе
                                f1 = false;//Меняем флаг
                            }
                        }
                    }
                }
                if (f == true && f1 == true) {//Если из вершины уже некуда переходить
                    vertex = arr_size;//Присваиваем значение вершине, чтобы выдти из цикла
                }
                else {
                    vertex = hasVertex;//Переход на следующую вершину
                }   
                
            }
            int comp = 0;
            bool isConnection = false;
            //Делаем проверку, что минимум две вершины входят в компонент связности
            for (int i = 0; i < arr_size; i++)
            {
                if (visArr[i] == 1) {
                    comp++;
                }
                if (comp >= 2) {
                    isConnection = true;
                    break;
                }

            }
            if (isConnection) //Если нашли компонент связности выводим на данные на консоль
            {
                connect++;
                for (int i = 0; i < arr_size; i++)
                {
                    if (visArr[i] == 1)
                    {
                        std::cout << (i + 1) << " - " << connect << std::endl;
                    }
                }
            }
 
            delete[] visArr;//Очищаем динамическую память

            int c = 0;//Счетчик вершин, которые уже проверили
            bool first = true;//Переменная, которая будет отслеживать первую вершину, которая еще не проверена
            for (int i = 0; i < arr_size; i++)//Проходим по массиву с уже проверенными вершинами
            {
                if (vArr[i] == 1) //Проверяем вершину на посещаемость
                {
                    c++;//Увеличиваем счетчик

                } else { //Если вершина еще не была на проверке

                    if (first == true) //Это первая попавшаяся вершина
                    {
                        vertex = i; //Следующий проход будет начинаться с этой вершины
                        first = false;//Меняем флаг
                    }
                }
            }
            if (c == arr_size) {//Если уже все вершины были проверены
                stopSearch = true;//Меняем флаг и выходим из цикла
            }
            


        } while (!stopSearch);

        std::cout <<"Количество компонентов связности в графе: " << connect << std::endl;
        std::cout << std::endl;
        

        delete[] vArr; //Очищаем динамическую память
        delete2dArr(fArr, arr_size);//Очищаем динамическую память

    }
    else //Предупреждение на случай, если файл input.txt отсутствует
    {
        std::cout << "file input.txt not found!!! Файл input.txt не найден!!!" << std::endl;
    }

    return 0;
}




